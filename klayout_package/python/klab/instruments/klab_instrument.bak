"""
klab - A Python package for KLayout integration with lab instrumentation.

This package provides tools and utilities to enhance and automate instrument control in KLayout,
a popular layout viewer and editor for integrated circuits.

Copyright (c) 2025, Technology Innovation Institute. All rights reserved.

"""
# ==================================================================
# This file defines the core architecture for instruments, featuring
# a base class for VISA communication and a specialized SCPI class
# with a dynamic proxy for on-the-fly command generation.
# ==================================================================

import pyvisa as visa
import time
import yaml
import os
import re
from abc import ABC, abstractmethod
from typing import Tuple, List, Union

class _QueryMarker: pass
q = _QueryMarker()

class NoQuote:
    """
    A wrapper class to indicate that a string argument should not be
    enclosed in quotation marks when sent in a SCPI command.
    
    Example:
        smu.source.function(NoQuote('VOLT')) # Sends: :SOUR:FUNC VOLT
    """
    def __init__(self, value):
        self.value = str(value)
    
    def __str__(self):
        return self.value
    


# --- Base Instrument Class ---
class KlabInstrument(ABC):
    """The absolute base class for any instrument in klab."""
    def __init__(self, name, address, timeout=5000, **kwargs):
        self.name = name
        self.address = address
        self._visa_instrument = None
        try:
            resource_manager = visa.ResourceManager()
            self._visa_instrument = resource_manager.open_resource(self.address)
            self._visa_instrument.timeout = timeout
            print(f"Successfully connected to {self.name}.")
        except Exception as e:
            print(f"Error connecting to {self.name} at {self.address}: {e}")
            self._visa_instrument = None

    def write(self, cmd: str):
        print(f"  > WRITE: {cmd}")
        if self._visa_instrument is None: return
        self._visa_instrument.write(cmd)

    def ask(self, cmd: str) -> str:
        print(f"  > QUERY: {cmd}")
        if self._visa_instrument is None: return ""
        response = self._visa_instrument.query(cmd)
        print(f"    < RESPONSE: {response.strip()}")
        return response
        
    def close(self):
        if self._visa_instrument:
            self._visa_instrument.close()
    
    def __del__(self):
        self.close()

# --- Dynamic SCPI Command Proxy ---
class SCPICommandProxy:
    """A proxy object to dynamically build and send SCPI commands."""
    def __init__(self, instrument, command_parts=[]):
        self._instrument = instrument
        self._command_parts = command_parts

    def __getattr__(self, name):
        """Appends a new command part when an attribute is accessed."""
        new_parts = self._command_parts + [name.upper()]
        return SCPICommandProxy(self._instrument, new_parts)

    def __getitem__(self, key):
        """Appends an index to the last command part."""
        if not self._command_parts:
            raise ValueError("Cannot use item access on an empty command path.")
        last_part = self._command_parts[-1] + str(key)
        new_parts = self._command_parts[:-1] + [last_part]
        return SCPICommandProxy(self._instrument, new_parts)

    def __call__(self, *args):
        """
        Executes the command when the chain is called as a function.
        - `cmd()`: Getter query -> `CMD?`
        - `cmd(arg)`: Setter -> `CMD arg`
        - `cmd(q, arg)`: Getter query with arguments -> `CMD? arg`
        """
        command_str = ":".join(self._command_parts)
        
        # --- UPDATED LOGIC ---
        if args and args[0] is q:
            # Case 1: Query with arguments. e.g., cmd(q, "param") -> CMD? 'param'
            command_str += "?"
            # Use the rest of the arguments for the query
            query_args = args[1:]
            if query_args:
                formatted_args = []
                for arg in query_args:
                    if isinstance(arg, NoQuote):
                        formatted_args.append(str(arg))
                    elif isinstance(arg, str):
                        formatted_args.append(f"'{arg}'")
                    else:
                        formatted_args.append(str(arg))
                args_str = ",".join(formatted_args)
                command_str += f" {args_str}"
            return self._instrument.ask(command_str)

        elif args:
            # Case 2: Standard setter with arguments. e.g., cmd("param") -> CMD 'param'
            formatted_args = []
            for arg in args:
                if isinstance(arg, NoQuote):
                    formatted_args.append(str(arg))
                elif isinstance(arg, str):
                    formatted_args.append(f"'{arg}'")
                else:
                    formatted_args.append(str(arg))

            args_str = ",".join(formatted_args)
            command_str += f" {args_str}"
            return self._instrument.write(command_str)
        else:
            # Case 3: Standard getter without arguments. e.g., cmd() -> CMD?
            command_str += "?"
            return self._instrument.ask(command_str)

import functools
def yaml_method(func):
    """Decorator that marks a method as being implemented in YAML.
    
    This allows abstract methods to be satisfied while delegating to YAML.
    """
    @functools.wraps(func)
    def wrapper(self, *args, **kwargs):
        # Convert positional args to kwargs based on function signature
        import inspect
        sig = inspect.signature(func)
        params = list(sig.parameters.keys())[1:]  # Skip 'self'
        
        for i, arg in enumerate(args):
            if i < len(params):
                kwargs[params[i]] = arg
        
        # Delegate to the YAML implementation
        method_name = func.__name__
        return self._execute_yaml_method(method_name, **kwargs)
        
    wrapper._is_yaml_method = True
    return wrapper

# --- SCPI Instrument Specialization ---
class ScpiInstrument(KlabInstrument):
    """An instrument that uses SCPI and supports dynamic command generation and YAML-based method definitions."""
    def __init__(self, name, address, yaml_file=None, **kwargs):
        super().__init__(name, address, **kwargs)
        self.spec = {}
        self.yaml_methods = []
        if yaml_file:
            self._load_spec_from_yaml(yaml_file)
            self._discover_yaml_methods()
            self._validate_yaml_methods()

    def _discover_yaml_methods(self):
        """Discover and list methods defined in the YAML spec file."""
        if 'methods' in self.spec:
            self.yaml_methods = list(self.spec['methods'].keys())
            print(f"\nAvailable YAML-defined methods for {self.name}:")
            for method in self.yaml_methods:
                print(f"  - {method}")

    def _validate_yaml_methods(self):
        """Validate that all methods marked as YAML methods have YAML implementations."""
        yaml_required_methods = []
        
        # Find all methods marked with @yaml_method
        for attr_name in dir(self.__class__):
            if attr_name.startswith('__'):
                continue
                
            attr = getattr(self.__class__, attr_name)
            if callable(attr) and hasattr(attr, '_is_yaml_method'):
                yaml_required_methods.append(attr_name)

        # Check that they have corresponding YAML implementations
        missing_methods = []
        for method_name in yaml_required_methods:
            if 'methods' not in self.spec or method_name not in self.spec['methods']:
                missing_methods.append(method_name)
        
        if missing_methods:
            raise NotImplementedError(
                f"The following methods are marked as @yaml_method but have no "
                f"implementation in the YAML file '{self._yaml_file}': {missing_methods}"
            )

    def _implement_yaml_abstract_methods(self):
        """Dynamically implement abstract methods using YAML definitions."""
        # Get abstract methods from all parent classes
        abstract_methods = set()
        for cls in self.__class__.__mro__:
            if hasattr(cls, '__abstractmethods__'):
                abstract_methods.update(cls.__abstractmethods__)

        # Check which abstract methods have YAML implementations
        implemented_methods = []
        for method_name in abstract_methods:
            if 'methods' in self.spec and method_name in self.spec['methods']:
                # Create a dynamic method that calls _execute_yaml_method
                def create_method(method_name):
                    def yaml_method(self, **params):
                        return self._execute_yaml_method(method_name, **params)
                    yaml_method.__name__ = method_name
                    return yaml_method
                
                # Add the dynamic method to the instance (not the class)
                bound_method = create_method(method_name).__get__(self, self.__class__)
                setattr(self, method_name, bound_method)
                implemented_methods.append(method_name)
        
        if implemented_methods:
            print(f"\nImplemented abstract methods via YAML for {self.name}:")
            for method in implemented_methods:
                print(f"  - {method}")

    def _load_spec_from_yaml(self, yaml_file):
        """Loads the instrument specification from a YAML file."""
        try:
            current_dir = os.path.dirname(os.path.abspath(__file__))
            project_root = os.path.dirname(current_dir)
            yaml_path = os.path.join(project_root, 'tech', yaml_file)

            # Chgeck in the project root and in the package root (its parent)
            if not os.path.exists(yaml_path):
                project_root = os.path.dirname(project_root)
                yaml_path = os.path.join(project_root, 'tech', yaml_file)
                
            if os.path.exists(yaml_path):
                with open(yaml_path, 'r') as f:
                    self.spec = yaml.safe_load(f)
                print(f"Loaded specification for '{self.name}' from '{yaml_file}'")
            else:
                raise FileNotFoundError(f"YAML file not found at {yaml_path}")
        except Exception as e:
            print(f"Warning: Could not load YAML spec '{yaml_file}'. Error: {e}")

    def __getattr__(self, name):
        """
        The entry point for all dynamic methods.
        It first checks for a high-level YAML method, then falls back
        to the dynamic SCPI command proxy.
        """
        # Check if the called name is a high-level method defined in the YAML file.
        if 'methods' in self.spec and name in self.spec['methods']:
            # Return a callable function that will execute the YAML sequence.
            def method_caller(**kwargs):
                self._execute_yaml_method(name, **kwargs)
            return method_caller

        # If it's not a YAML method, create the dynamic SCPI command proxy.
        # This is the starting point of the chain.
        return SCPICommandProxy(self, [name.upper()])

    def _safe_nested_call(self, call_string: str):
        """
        Safely parses and calls a nested method string from YAML without using eval().
        Example: "set_current(current=1e-6, vlim=0.1)"
        """
        match = re.match(r"^\s*([\w\.]+)\((.*)\)\s*$", call_string)
        if not match:
            raise ValueError(f"Invalid nested method format in YAML: '{call_string}'")

        method_name, args_str = match.groups()
        method_to_call = getattr(self, method_name)
        
        # Parse keyword arguments
        kwargs_to_pass = {}
        if args_str.strip():
            # This parser is simple and assumes no commas within argument values
            arg_pairs = [p.strip() for p in args_str.split(',')]
            for pair in arg_pairs:
                key, value_str = [p.strip() for p in pair.split('=', 1)]
                # Try to convert value to a number, otherwise treat as a string
                try:
                    value = float(value_str)
                    if value.is_integer():
                        value = int(value)
                except ValueError:
                    value = value_str.strip("'\"") # Strip quotes
                kwargs_to_pass[key] = value

        return method_to_call(**kwargs_to_pass)

    def _execute_yaml_method(self, method_name, **kwargs):
        if 'methods' not in self.spec or method_name not in self.spec['methods']:
            raise AttributeError(f"Method '{method_name}' not found in YAML specification.")
        
        print(f"Executing YAML method: '{method_name}'")
        command_sequence = self.spec['methods'][method_name]
        last_response = None
        for command in command_sequence:
            formatted_command = command.format(**kwargs)
            
            # Check if the command is a nested method call or a raw SCPI command
            if '(' in formatted_command and ')' in formatted_command:
                print(f"  > Executing nested method: {formatted_command}")
                # Use the new safe parser and caller instead of eval
                last_response = self._safe_nested_call(formatted_command)
            else:
                # This is a raw SCPI command
                if "?" in formatted_command:
                    last_response = self.ask(formatted_command)
                else:
                    self.write(formatted_command)
        return last_response

    def get_available_methods(self):
        """Returns a dictionary with information about available methods.
        
        Returns:
            dict: Contains 'yaml_methods', 'python_methods', and 'all_methods' keys
        """
        # Get Python-defined methods (excluding built-ins and private methods)
        python_methods = [
            method for method in dir(self) 
            if callable(getattr(self, method)) 
            and not method.startswith('_')
            and method not in dir(KlabInstrument)  # Exclude base class methods
        ]
        
        return {
            'yaml_methods': self.yaml_methods,
            'python_methods': python_methods,
            'all_methods': list(set(self.yaml_methods + python_methods))
        }

    # --- Common SCPI Commands ---
    def get_idn(self) -> dict:
        """Gets the instrument's identification string (*IDN?)."""
        response = self.ask("*IDN?")
        parts = response.strip().split(',')
        return {'vendor': parts[0], 'model': parts[1], 'serial': parts[2], 'firmware': parts[3]}

    def reset(self):
        """Resets the instrument (*RST)."""
        self.write("*RST")
        
    def clear_status(self):
        """Clears the status byte and error queue (*CLS)."""
        self.write("*CLS")

    def wait_for_op_complete(self):
        """Waits for all pending operations to complete (*WAI)."""
        self.write("*WAI")

    def get_status_byte(self) -> int:
        """Gets the status byte of the instrument (STB?)."""
        response = self.ask("*STB?")
        return int(response.strip())

# --- Abstract Classes ---
# These classes define the interface for specific instrument types. They can be used to create concrete
# implementations for specific instruments drivers and ensure cross-compatibility.

# Abstract classes of type SCPI will inherit the SCPI Command Proxy for dynamic command generation.
class SMU(ScpiInstrument, ABC):
    """Abstract Base Class for a Source-Measure Unit."""
    @abstractmethod
    def source_voltage(self, voltage: float, current_compliance: float): raise NotImplementedError
    @abstractmethod
    def source_current(self, current: float, voltage_compliance: float): raise NotImplementedError
    @abstractmethod
    def measure_voltage(self, nplc: int) -> float: raise NotImplementedError
    @abstractmethod
    def measure_current(self, nplc: int) -> float: raise NotImplementedError
    @abstractmethod
    def enable_source(self, enable: bool): raise NotImplementedError

#  Non SCPI instruments can still use the base class KlabInstrument provided visa can be used for communication.
class MotorStage(KlabInstrument):
    """Abstract Base Class for a Motorized Stage."""
    @abstractmethod
    def get_position(self, axis: int = 0) -> float: raise NotImplementedError
    @abstractmethod
    def move_to(self, position: float, axis: int = 0): raise NotImplementedError
    @abstractmethod
    def move_by(self, distance: float, axis: int = 0): raise NotImplementedError
    @abstractmethod
    def set_speed(self, speed: float, axis: int = 0): raise NotImplementedError
    @abstractmethod
    def stop(self, axis: int = 0): raise NotImplementedError






if __name__ == "__main__":
    # Example usage of the KlabInstrument and SCPIInstrument classes.
    # This is a driverless example to demonstrate connect to an instrument 
    # in absense of drivers, and with no direct SCPI queries.
    try:
        smu = ScpiInstrument(name="SMU", address="TCPIP::192.168.0.95::INSTR")
        smu.write(":SOUR:FUNC CURR") # Example fo direct use of SCPI command
        smu.sour.curr(5e-9)
        smu.sour.curr.vlim(0.2)
        smu.sens.func('VOLT')
        smu.sens.volt.nplc(1)
        smu.count(5)
        smu.outp(NoQuote('ON')) 
        smu.trac.trig("defbuffer1")
        # Fetch data from the trace buffer. The use of the query marker `q` allows
        # to pass  queries with arguments.
        output = smu.trac.data(q,1,5,"defbuffer1", NoQuote('SOUR'),NoQuote('READ'))
        smu.write(":OUTP OFF")
        print(f"Measured voltage: {output} V")
        smu.close()
    except Exception as e:
        print(f"Error occurred: {e}")
        smu.close()
